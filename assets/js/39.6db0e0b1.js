(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{583:function(e,a,t){"use strict";t.r(a);var n=t(12),l=Object(n.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("p",[e._v("标签：双向链表 哈希表 中等")])]),e._v(" "),t("h2",{attrs:{id:"题目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#题目"}},[e._v("#")]),e._v(" 题目")]),e._v(" "),t("p",[e._v("请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。\n实现 LRUCache 类：\n"),t("code",[e._v("LRUCache(int capacity)")]),e._v(" 以 正整数 作为容量 capacity 初始化 LRU 缓存\n"),t("code",[e._v("int get(int key)")]),e._v(" 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\n"),t("code",[e._v("void put(int key, int value)")]),e._v(" 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。")]),e._v(" "),t("p",[e._v("示例：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('输入\n["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\n解释\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1);    // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2);    // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1);    // 返回 -1 (未找到)\nlRUCache.get(3);    // 返回 3\nlRUCache.get(4);    // 返回 4\n')])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br"),t("span",{staticClass:"line-number"},[e._v("12")]),t("br"),t("span",{staticClass:"line-number"},[e._v("13")]),t("br"),t("span",{staticClass:"line-number"},[e._v("14")]),t("br"),t("span",{staticClass:"line-number"},[e._v("15")]),t("br"),t("span",{staticClass:"line-number"},[e._v("16")]),t("br"),t("span",{staticClass:"line-number"},[e._v("17")]),t("br")])]),t("p",[e._v("提示：")]),e._v(" "),t("ol",[t("li",[e._v("1 <= capacity <= 3000")]),e._v(" "),t("li",[e._v("0 <= key <= 10000")]),e._v(" "),t("li",[e._v("0 <= value <= 10^5")]),e._v(" "),t("li",[e._v("最多调用 2 * 10^5 次 get 和 put")])]),e._v(" "),t("h2",{attrs:{id:"解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析"}},[e._v("#")]),e._v(" 解析")]),e._v(" "),t("p",[e._v("虽然昨天已经看过了别人的思路，但是今天自己写的时候还是...不知道是哪一块出了问题，花费的时间太多，下次再来吧😭。看到有两种比较好的方法：")]),e._v(" "),t("ol",[t("li",[e._v("哈希表\n"),t("ul",[t("li",[e._v("借助哈希表新增键值对在尾部的特点。如果最近刚使用过的，存放在哈希表尾部；如果很久没有使用过，则放在头部。")]),e._v(" "),t("li",[e._v("如果长度超出所给容量，则删除哈希表中的第一对键值对："),t("code",[e._v("map.delete(map.keys().next().value);")]),e._v("。")]),e._v(" "),t("li",[e._v("该题解借鉴于"),t("a",{attrs:{href:"https://leetcode-cn.com/problems/lru-cache/solution/mapjie-fa-jian-dan-yi-dong-by-bella0929-8lpn/",target:"_blank",rel:"noopener noreferrer"}},[e._v("map解法简单易懂"),t("OutboundLink")],1)])])]),e._v(" "),t("li",[e._v("哈希表+双向链表\n"),t("ul",[t("li",[e._v("要使get与put时间复杂度为O(1)，可以使用双向链表+哈希表的结构")]),e._v(" "),t("li",[e._v("get：借助哈希表O(1)的查找速度+链表O(1)的插入操作；put：哈希表O(1)的查找速度+链表O(1)的插入与删除操作")]),e._v(" "),t("li",[e._v("其中双向链表头结点为最近被访问的结点，尾结点为最长时间未被访问的结点。")]),e._v(" "),t("li",[e._v("哈希表中存的是(key,node)，这样可以访问key看是否存在，然后去node中取值，这样是为了方便与链表节点一一对应，删除的时候更方便找到那个节点。")]),e._v(" "),t("li",[e._v("要注意的是，刚开始要初始化一个头结点和尾节点，这样就不需要额外判断头尾是否为空的情况。")]),e._v(" "),t("li",[e._v("该题解借鉴于"),t("a",{attrs:{href:"https://leetcode-cn.com/problems/lru-cache/solution/bu-yong-yu-yan-nei-jian-de-map-gua-dang-feng-zhuan/",target:"_blank",rel:"noopener noreferrer"}},[e._v("分析为什么用双向链表？| 不用库函数 纯手写实现 |146. LRU 缓存"),t("OutboundLink")],1)])])])]),e._v(" "),t("p",[e._v("JavaScript代码上面都有，就不贴我那丑陋的代码啦🤡~")])])}),[],!1,null,null,null);a.default=l.exports}}]);