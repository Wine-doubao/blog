<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 小迷糊</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/blog/logo.png">
    <meta name="description" content="一名喜欢学习、探索新知识的前端程序媛，记录自己的前端成长之路，前端路上不迷糊">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    
    <link rel="preload" href="/blog/assets/css/0.styles.4607b592.css" as="style"><link rel="preload" href="/blog/assets/js/app.14bc1ec9.js" as="script"><link rel="preload" href="/blog/assets/js/3.38776f79.js" as="script"><link rel="preload" href="/blog/assets/js/1.88753400.js" as="script"><link rel="preload" href="/blog/assets/js/88.4dd8de33.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.03f17d16.js"><link rel="prefetch" href="/blog/assets/js/11.86f3b9ac.js"><link rel="prefetch" href="/blog/assets/js/12.4b911d63.js"><link rel="prefetch" href="/blog/assets/js/13.ca30070e.js"><link rel="prefetch" href="/blog/assets/js/14.e5e9227c.js"><link rel="prefetch" href="/blog/assets/js/15.c0578f4b.js"><link rel="prefetch" href="/blog/assets/js/16.222c190c.js"><link rel="prefetch" href="/blog/assets/js/17.bd0f7996.js"><link rel="prefetch" href="/blog/assets/js/18.2d3283aa.js"><link rel="prefetch" href="/blog/assets/js/19.b7b0b27b.js"><link rel="prefetch" href="/blog/assets/js/20.94b0c3e5.js"><link rel="prefetch" href="/blog/assets/js/21.a2bc550f.js"><link rel="prefetch" href="/blog/assets/js/22.f1ff2b7d.js"><link rel="prefetch" href="/blog/assets/js/23.158f1154.js"><link rel="prefetch" href="/blog/assets/js/24.d4b71a98.js"><link rel="prefetch" href="/blog/assets/js/25.cef79d58.js"><link rel="prefetch" href="/blog/assets/js/26.80ac6d2d.js"><link rel="prefetch" href="/blog/assets/js/27.4e14ff5a.js"><link rel="prefetch" href="/blog/assets/js/28.d8953d4a.js"><link rel="prefetch" href="/blog/assets/js/29.7e333c29.js"><link rel="prefetch" href="/blog/assets/js/30.e2d7153a.js"><link rel="prefetch" href="/blog/assets/js/31.a8e81d66.js"><link rel="prefetch" href="/blog/assets/js/32.dfa2ad20.js"><link rel="prefetch" href="/blog/assets/js/33.b1df30ae.js"><link rel="prefetch" href="/blog/assets/js/34.05f7f73d.js"><link rel="prefetch" href="/blog/assets/js/35.9c182549.js"><link rel="prefetch" href="/blog/assets/js/36.7a17e340.js"><link rel="prefetch" href="/blog/assets/js/37.46864d28.js"><link rel="prefetch" href="/blog/assets/js/38.efaa226d.js"><link rel="prefetch" href="/blog/assets/js/39.6db0e0b1.js"><link rel="prefetch" href="/blog/assets/js/4.c1935ad0.js"><link rel="prefetch" href="/blog/assets/js/40.3c1ea0c1.js"><link rel="prefetch" href="/blog/assets/js/41.9bee1653.js"><link rel="prefetch" href="/blog/assets/js/42.0cbf02c4.js"><link rel="prefetch" href="/blog/assets/js/43.bdb7cfed.js"><link rel="prefetch" href="/blog/assets/js/44.d38e848a.js"><link rel="prefetch" href="/blog/assets/js/45.959b99b7.js"><link rel="prefetch" href="/blog/assets/js/46.30879127.js"><link rel="prefetch" href="/blog/assets/js/47.12e61563.js"><link rel="prefetch" href="/blog/assets/js/48.1a23bc9d.js"><link rel="prefetch" href="/blog/assets/js/49.f3a07a73.js"><link rel="prefetch" href="/blog/assets/js/5.b81564a8.js"><link rel="prefetch" href="/blog/assets/js/50.58b060dc.js"><link rel="prefetch" href="/blog/assets/js/51.abe1e4bc.js"><link rel="prefetch" href="/blog/assets/js/52.a8be2591.js"><link rel="prefetch" href="/blog/assets/js/53.6c1ed115.js"><link rel="prefetch" href="/blog/assets/js/54.b77c83b7.js"><link rel="prefetch" href="/blog/assets/js/55.cf5fc38d.js"><link rel="prefetch" href="/blog/assets/js/56.e01138bd.js"><link rel="prefetch" href="/blog/assets/js/57.b73c4090.js"><link rel="prefetch" href="/blog/assets/js/58.b77da72a.js"><link rel="prefetch" href="/blog/assets/js/59.fa55d054.js"><link rel="prefetch" href="/blog/assets/js/6.886bfdc8.js"><link rel="prefetch" href="/blog/assets/js/60.65fc8e02.js"><link rel="prefetch" href="/blog/assets/js/61.42be726f.js"><link rel="prefetch" href="/blog/assets/js/62.b5449f12.js"><link rel="prefetch" href="/blog/assets/js/63.d33e5f85.js"><link rel="prefetch" href="/blog/assets/js/64.b69f3d0b.js"><link rel="prefetch" href="/blog/assets/js/65.a2e7fee2.js"><link rel="prefetch" href="/blog/assets/js/66.de4c93a7.js"><link rel="prefetch" href="/blog/assets/js/67.5d2cbf4a.js"><link rel="prefetch" href="/blog/assets/js/68.d2655689.js"><link rel="prefetch" href="/blog/assets/js/69.06adeaad.js"><link rel="prefetch" href="/blog/assets/js/7.1cfb3480.js"><link rel="prefetch" href="/blog/assets/js/70.24b81a64.js"><link rel="prefetch" href="/blog/assets/js/71.859eda2a.js"><link rel="prefetch" href="/blog/assets/js/72.3c5ed41d.js"><link rel="prefetch" href="/blog/assets/js/73.6a9a1d3c.js"><link rel="prefetch" href="/blog/assets/js/74.892b6e0e.js"><link rel="prefetch" href="/blog/assets/js/75.bb4a8109.js"><link rel="prefetch" href="/blog/assets/js/76.9aaecf70.js"><link rel="prefetch" href="/blog/assets/js/77.139061e4.js"><link rel="prefetch" href="/blog/assets/js/78.fb3f9354.js"><link rel="prefetch" href="/blog/assets/js/79.d7648b35.js"><link rel="prefetch" href="/blog/assets/js/8.b351ed33.js"><link rel="prefetch" href="/blog/assets/js/80.e432d76e.js"><link rel="prefetch" href="/blog/assets/js/81.837374f7.js"><link rel="prefetch" href="/blog/assets/js/82.3f65934c.js"><link rel="prefetch" href="/blog/assets/js/83.1f6b84d9.js"><link rel="prefetch" href="/blog/assets/js/84.9cddee26.js"><link rel="prefetch" href="/blog/assets/js/85.526d5b2c.js"><link rel="prefetch" href="/blog/assets/js/86.cc007c0a.js"><link rel="prefetch" href="/blog/assets/js/87.e7f0a90f.js"><link rel="prefetch" href="/blog/assets/js/9.3fd200c6.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.4607b592.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1156296a><div data-v-1156296a><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1156296a data-v-1156296a><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-4e82dffc data-v-1156296a data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>小迷糊</h3> <p class="description" data-v-4e82dffc data-v-4e82dffc>一名喜欢学习、探索新知识的前端程序媛，记录自己的前端成长之路，前端路上不迷糊</p> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>doubao</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div class="hide" data-v-1156296a><header class="navbar" data-v-1156296a><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/logo.png" alt="小迷糊" class="logo"> <span class="site-name">小迷糊</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/JavaScript/" class="nav-link"><i class="undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/LeetCode/" class="nav-link"><i class="undefined"></i>
  LeetCode
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/CSS/" class="nav-link"><i class="undefined"></i>
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/git/" class="nav-link"><i class="undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/Node.js/" class="nav-link"><i class="undefined"></i>
  Node.js
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/other/" class="nav-link"><i class="undefined"></i>
  other
</a></li></ul></div></div><div class="nav-item"><a href="/blog/docs/interview/html.html" class="nav-link"><i class="iconfont reco-message"></i>
  面经
</a></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-1156296a></div> <aside class="sidebar" data-v-1156296a><div class="personal-info-wrapper" data-v-828910c6 data-v-1156296a><img src="/blog/logo.png" alt="author-avatar" class="personal-img" data-v-828910c6> <h3 class="name" data-v-828910c6>
    doubao
  </h3> <div class="num" data-v-828910c6><div data-v-828910c6><h3 data-v-828910c6>78</h3> <h6 data-v-828910c6>文章</h6></div> <div data-v-828910c6><h3 data-v-828910c6>31</h3> <h6 data-v-828910c6>标签</h6></div></div> <ul class="social-links" data-v-828910c6></ul> <hr data-v-828910c6></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link"><i class="iconfont reco-home"></i>
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/categories/工具/" class="nav-link"><i class="undefined"></i>
  工具
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/JavaScript/" class="nav-link"><i class="undefined"></i>
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/LeetCode/" class="nav-link"><i class="undefined"></i>
  LeetCode
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/CSS/" class="nav-link"><i class="undefined"></i>
  CSS
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/git/" class="nav-link"><i class="undefined"></i>
  git
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/Node.js/" class="nav-link"><i class="undefined"></i>
  Node.js
</a></li><li class="dropdown-item"><!----> <a href="/blog/categories/other/" class="nav-link"><i class="undefined"></i>
  other
</a></li></ul></div></div><div class="nav-item"><a href="/blog/docs/interview/html.html" class="nav-link"><i class="iconfont reco-message"></i>
  面经
</a></div><div class="nav-item"><a href="/blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><a href="/blog/timeline/" class="nav-link"><i class="iconfont reco-date"></i>
  时间轴
</a></div> <!----></nav> <ul class="sidebar-links"><li><a href="/blog/docs/interview/html.html" class="sidebar-link">HTML</a></li><li><a href="/blog/docs/interview/css.html" class="sidebar-link">CSS</a></li><li><a href="/blog/docs/interview/javascript.html" class="sidebar-link">JavaScript</a></li><li><a href="/blog/docs/interview/vue.html" aria-current="page" class="active sidebar-link">Vue</a></li><li><a href="/blog/docs/interview/chrome.html" class="sidebar-link">浏览器</a></li><li><a href="/blog/docs/interview/network.html" class="sidebar-link">计算机网络</a></li><li><a href="/blog/docs/interview/operatingSystem.html" class="sidebar-link">操作系统</a></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-4e82dffc data-v-1156296a><h3 class="title" data-v-4e82dffc data-v-4e82dffc>Vue</h3> <!----> <label id="box" class="inputBox" data-v-4e82dffc data-v-4e82dffc><input type="password" value="" data-v-4e82dffc> <span data-v-4e82dffc>Konck! Knock!</span> <button data-v-4e82dffc>OK</button></label> <div class="footer" data-v-4e82dffc data-v-4e82dffc><span data-v-4e82dffc><i class="iconfont reco-theme" data-v-4e82dffc></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-4e82dffc>vuePress-theme-reco</a></span> <span data-v-4e82dffc><i class="iconfont reco-copyright" data-v-4e82dffc></i> <a data-v-4e82dffc><span data-v-4e82dffc>doubao</span>
            
          <span data-v-4e82dffc>2021 - </span>
          2022
        </a></span></div></div> <div data-v-1156296a><main class="page"><section><div class="page-title"><h1 class="title">Vue</h1> <div data-v-1ff7123e><i class="iconfont reco-account" data-v-1ff7123e><span data-v-1ff7123e>doubao</span></i> <!----> <i class="iconfont reco-eye" data-v-1ff7123e><span id="/blog/docs/interview/vue.html" data-flag-title="Your Article Title" class="leancloud-visitors" data-v-1ff7123e><a class="leancloud-visitors-count" style="font-size:.9rem;font-weight:normal;color:#999;"></a></span></i> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="vue基础"><a href="#vue基础" class="header-anchor">#</a> Vue基础</h2> <h3 id="computed、watch与methods"><a href="#computed、watch与methods" class="header-anchor">#</a> computed、watch与methods</h3> <p><strong>computed</strong>：</p> <ol><li>支持缓存，计算属性是基于响应式依赖进行缓存的，也就是data中或父组件传过来的props中的数据，只有在响应式数据发生变化才会重新计算</li> <li>不支持异步，当computed中有异步操作时，无法监听数据的变化</li> <li>计算属性中函数的返回值就是属性的属性值</li> <li><code>应用场景</code>：需要进行数值计算，且依赖于其他数据，可以利用computed的缓存特性，避免每次获取值都要重新计算。</li></ol> <p><strong>watch</strong>:</p> <ol><li>不支持缓存，只要监听的数据变化，就会触发，监听数据必须是响应式数据</li> <li>支持异步监听，监听函数接收两个值：新值和旧值</li> <li><code>应用场景</code>：需要在数据变化时执行异步或开销较大的操作，watch可以限制执行该操作的频率，并在得到最终结果前设置中间状态，这是计算属性无法做到的。</li></ol> <p>可以将同一函数定义为 method 或 computed，对于最终的结果，两种方式都是相同的。但是计算属性可以缓存，而method调用总会执行该函数。</p> <h3 id="v-if、v-show与v-html"><a href="#v-if、v-show与v-html" class="header-anchor">#</a> v-if、v-show与v-html</h3> <p><strong>v-if</strong>:</p> <ol><li>v-if是惰性的，如果初始条件为假，则渲染时会忽略对应节点；只有在条件第一次变为真时才开始局部编译</li> <li>v-if切换有一个局部编译/卸载的过程，切换过程中会销毁和重建内部的事件监听和子组件</li> <li>v-if有更高的切换消耗，适合条件不容易被改变的情况</li></ol> <p><strong>v-show</strong>：</p> <ol><li>无论首次条件是否为真，都被编译，然后缓存，而且DOM元素保留</li> <li>v-show是通过设置DOM元素的display样式属性控制显隐的</li> <li>v-show有更高的初始渲染消耗，适合需要频繁切换的场景</li></ol> <p><strong>v-html</strong>：会先移除节点下的所有子节点，调用html方法，通过addProp给节点设置innerHTML为v-html的值。</p> <h3 id="v-if和v-for的优先级问题"><a href="#v-if和v-for的优先级问题" class="header-anchor">#</a> v-if和v-for的优先级问题</h3> <ul><li>在Vue2.x中，v-for优先于v-if，如果同时出现，每次渲染都会执行循环再判断条件，这样渲染就不可避免，浪费性能。</li> <li>在Vue3.x中，v-if优先于v-for。</li></ul> <p>由于语法上存在歧义，建议避免在同一元素上同时使用两者。更好的办法是通过创建计算属性筛选出列表，一次创建可见元素。</p> <h3 id="v-model语法糖"><a href="#v-model语法糖" class="header-anchor">#</a> v-model语法糖</h3> <h3 id="data为什么是一个函数而不是对象"><a href="#data为什么是一个函数而不是对象" class="header-anchor">#</a> data为什么是一个函数而不是对象</h3> <p>Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。</p> <p>而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。</p> <h3 id="slot插槽"><a href="#slot插槽" class="header-anchor">#</a> slot插槽</h3> <h3 id="对keep-alive组件的理解"><a href="#对keep-alive组件的理解" class="header-anchor">#</a> 对keep-alive组件的理解</h3> <p>keep-alive是Vue提供的一个内置组件，用来对组件进行缓存——<strong>在组件切换过程中将状态保留在内存中，防止重复渲染DOM</strong>。这也可以使用v-show来达到目的，但是v-show在初始渲染时会全部渲染，而keep-alive只有在被包裹的组件第一次切换时才被渲染并保存在内存中。</p> <p><strong>keep-alive的生命周期</strong>：</p> <p>如果为一个组件包裹了keep-alive，它会多出两个生命周期： <code>activated</code> 和 <code>deactivated</code> 。</p> <ul><li>当组件被切换时，会被缓存到内存中、触发 deactivated 生命周期；</li> <li>当组件被切换回来时，再去缓存里找这个组件、触发 activated 钩子函数。</li></ul> <p><a href="https://juejin.cn/post/6844903837770203144" target="_blank" rel="noopener noreferrer">彻底揭秘keep-alive原理<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="nexttick的原理及作用"><a href="#nexttick的原理及作用" class="header-anchor">#</a> $nextTick的原理及作用</h3> <p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p> <p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p> <h3 id="vm-set"><a href="#vm-set" class="header-anchor">#</a> vm.$set()</h3> <p>在Vue2.x，如果直接给vue中data的对象添加属性，或直接设置数组的某项值，会发现视图并未刷新。这是因为defineProperty的限制（Vue3的proxy可以完美解决这些问题），如果在Vue实例创建时没有声明，就不会被Vue转换成响应式属性，自然就不会触发视图的更新，这个时候就要使用Vue的全局api <code>$set()</code>。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span>要改变的数组<span class="token operator">/</span>对象<span class="token punctuation">,</span> 索引<span class="token operator">/</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 改变数组</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">,</span> <span class="token string">&quot;c&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;o&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 改变对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>vm.$set()实现原理</strong>：</p> <ul><li>如果目标是数组，直接使用数组的splice方法触发响应式（该方法已被vue重写）</li> <li>如果目标是对象，会先判断属性是否存在，对象是否为响应式。如果要对属性进行响应式处理，则通过调用<code>defineReactive</code>方法（该方式就是Vue在初始化对象时，给对象属性采用Object.defineProperty动态添加getter和setter功能所调用的方法）</li></ul> <h3 id="vue如何收集依赖"><a href="#vue如何收集依赖" class="header-anchor">#</a> Vue如何收集依赖</h3> <p><a href="https://www.yuque.com/cuggz/interview/hswu8g#58ba52edd552377ad2dd1fe94c42ffc3" target="_blank" rel="noopener noreferrer">参考<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="单页面应用与多页面应用"><a href="#单页面应用与多页面应用" class="header-anchor">#</a> 单页面应用与多页面应用</h3> <ul><li><strong>SPA单页面应用</strong>：只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。
<ul><li>优点：
<ol><li>用户体验好、内容改变不需要重新加载整个页面</li> <li>避免了不必要的重复渲染，SPA相对对服务器压力小</li></ol></li> <li>缺点：
<ol><li>初次加载耗时长</li> <li>前进后退路由管理：SPA在一个页面中显示所有内容，所以不能使用浏览器的前进后退功能，所有页面切换需要自己建立堆栈管理</li> <li>不利于SEO，所有内容都在一个页面中动态替换显示</li></ol></li></ul></li> <li><strong>MPA多页面应用</strong>：有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li></ul> <p><img src="https://s2.loli.net/2022/03/27/oW36Ffqn9KJUH7u.png" alt="image-20220309161624614"></p> <h3 id="预渲染"><a href="#预渲染" class="header-anchor">#</a> 预渲染</h3> <p>如果仅希望改善网站的一些推广页面 (例如<code>/</code>、<code>/about</code>、<code>/contact</code>等) 的SEO，预渲染比SSR更加合适。预渲染可以在构建时为指定的路由生成静态HTML文件，通俗来讲就是把希望被爬虫抓取的页面通过预渲染插件（webpack中的<code>prerender-spa-plugin</code>插件）来提前渲染出来，好让爬虫抓取这些内容，改善SEO。</p> <h3 id="ssr"><a href="#ssr" class="header-anchor">#</a> SSR</h3> <p>SSR即服务端渲染：将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后把html直接返回给客户端。它通常是由<strong>内容呈现时间对应用的重要程度</strong>决定的，SSR可以实现最佳的初始加载性能。</p> <p><strong>优点</strong>：</p> <ul><li>更好的SEO,因为搜索引擎爬虫会直接读取完整的渲染出来的页面。</li> <li>更快的内容呈现，尤其是网络连接缓慢或设备运行速度缓慢的时候。服务端标记不需要等待所有的 JavaScript 都被下载并执行之后才显示，所以用户可以更快看到完整的渲染好的内容。</li></ul> <p><strong>缺点</strong>：</p> <ul><li>开发条件会受限，浏览器特有的代码只能在特定的生命周期钩子中使用；一些外部的库在服务端渲染应用中可能需要经过特殊处理。SSR只支持调用<code>beforeCreate</code>和<code>created</code>两个钩子，其他只会在客户端执行。</li> <li>不同于一个完全静态的 SPA 可以部署在任意的静态文件服务器，服务端渲染应用需要一个能够运行 Node.js 服务器的环境。</li> <li>更多的服务端负载。在 Node.js 中渲染一个完整的应用会比仅供应静态文件产生更密集的 CPU 运算。所以如果流量很高，需要能够承担相应负载的服务器并采取缓存策略。</li></ul> <h2 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h2> <p>从Vue实例创建、运行、到销毁期间，会运行一些叫生命周期钩子的函数。主要的生命周期分类：</p> <ol><li>创建期间：beforeCreate、created、beforeMount、mounted
<ul><li>beforeCreate：在实例初始化之后，data的响应式追踪、event/watcher之前被调用，也就是说不能访问到data、computed、watch、methods上的数据和方法。</li> <li>created：实例创建完成之后被调用，实例上配置的options包括data、computed、watch、methods等都配置完成了，但是此时渲染节点还未挂载到DOM，所以不能访问到与实例绑定的 $el 属性对应的节点，如果想要与DOM进行交互，可以通过vm.$nextTick来访问DOM。</li> <li>beforeMount：在挂载前调用，相关的render函数首次被调用。完成以下配置：编译模板，把data里的数据和模板生成html。此时还没有挂载到html页面上。</li> <li>mounted：在挂载后调用，此时真实的DOM已经挂载完毕，数据已经被监测，可以访问DOM节点。</li></ul></li> <li>运行期间：beforeUpdate、updated
<ul><li>beforeUpdate：响应式数据更新时调用，发生在虚拟DOM重新渲染和打补丁（patch）之前。这里可以进一步变更状态，不会触发附加的重渲染过程。</li> <li>updated：发生在DOM更新完成之后，这期间避免更改数据，可能导致更新无限循环。</li></ul></li> <li>销毁期间：beforeDestroy、destroyed（beforeUnmount、unmounted）
<ul><li>beforeDestroy/beforeUnmount：实例销毁前调用，这里可以进行善后首尾工作，如清除定时器。</li> <li>destroyed/unmounted：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ul></li></ol> <p><code>异步请求</code>可以在 created、beforeMount、mounted 中进行，这里data可以访问，且可以将服务器返回的数据进行赋值。如果异步请求不依赖DOM，推荐在created中调用，有以下优点：</p> <ul><li>更快获取到服务端数据，减少页面loading时间；</li> <li>SSR不支持beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性。</li></ul> <p>Vue3的生命周期销毁阶段的钩子函数有了些变动，且新添了一些其他的<a href="https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html#beforecreate" target="_blank" rel="noopener noreferrer">生命周期函数<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。下图就是Vue3的生命周期图：</p> <p><img src="https://v3.cn.vuejs.org/images/lifecycle.svg" alt="实例的生命周期"></p> <h3 id="父子组件生命周期钩子执行顺序"><a href="#父子组件生命周期钩子执行顺序" class="header-anchor">#</a> 父子组件生命周期钩子执行顺序</h3> <ul><li>加载渲染过程：父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted</li> <li>子组件更新过程：父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated</li> <li>父组件更新过程：父 beforeUpdate-&gt;父 updated</li> <li>销毁过程：父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroyed</li></ul> <h2 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h2> <h3 id="props-emit"><a href="#props-emit" class="header-anchor">#</a> props/$emit</h3> <p>父组件通过 <code>props</code> 向子组件传递数据，子组件通过 <code>$emit</code> 和父组件通信。</p> <p><strong>父组件向子组件传值</strong>：</p> <ol><li>props可以为<strong>字符串数组</strong>或对象（键值分别为名称和数据类型）</li> <li>基本使用：<strong>父组件中使用子组件的时候给子组件添加要传入的属性，子组件通过props来接收父组件传入的属性</strong></li> <li><code>单向数据流</code>：props只能是父组件向子组件传值，反过来不行</li> <li><code>子组件避免修改prop</code>：js中对象和数组是通过引用传入的，所以在子组件中应该避免修改任何prop，防止应用的数据流向难以理解</li> <li><code>传递静态or动态的prop</code>：如果使用子组件时传入的属性是静态值，可以不适用 v-bind ；如果是动态的值，则使用 v-bind 绑定</li> <li><code>props 属性命名规则</code>：在 props 中使用驼峰形式，DOM模板中需要使用短横线的形式。如果使用字符串模板，就没有这个限制了</li></ol> <div class="language-html line-numbers-mode"><pre class="language-html"><code>props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
props: {
title: String,
likes: Number,
isPublished: Boolean,
commentIds: Array,
author: Object,
callback: Function,
contactsPromise: Promise // 或任何其他构造函数
}

<span class="token comment">&lt;!-- 子组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>son<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{postTitle}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>{{msg}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>fn<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>按钮<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">&quot;son&quot;</span><span class="token punctuation">,</span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> props使用驼峰 <span class="token operator">--</span><span class="token operator">&gt;</span>
    props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;postTitle&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;msg&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;fn&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>


<span class="token comment">&lt;!-- 父组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>father<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 传递静态or动态属性，模板中使用横线分隔方式 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>son</span> <span class="token attr-name">post-title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>hello!<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:msg</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>msgData<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:fn</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>myFunction<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>son</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> son <span class="token keyword">from</span> <span class="token string">&quot;./son.vue&quot;</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> father<span class="token punctuation">,</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      msgData<span class="token operator">:</span> <span class="token string">&quot;父组件数据&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;vue&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span>
      son
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><p><strong>子组件向父组件传值</strong>：</p> <ol><li>在父组件定义函数，在子组件通过<code>$emit('函数名', 要传的参数)</code>调用</li></ol> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>example<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>advice-component</span> <span class="token attr-name"><span class="token namespace">v-on:</span>advise</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>showAdvice<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>advice-component</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> adviceComponent <span class="token keyword">from</span> <span class="token string">'./text/adviceComponent.vue'</span>
  <span class="token comment">// 父组件实例</span>
  <span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">showAdvice</span><span class="token punctuation">(</span><span class="token parameter">advice</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">alert</span><span class="token punctuation">(</span>advice<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  <span class="token comment">// 注册子组件</span>
  app<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'adviceComponent'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    emits<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'advise'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">// vue3提供的，与props类似，定义一个组件可以向其父组件触发的事件</span>
    <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        adviceText<span class="token operator">:</span> <span class="token string">'Some advice'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// </span>
    template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
      &lt;div&gt;
        &lt;input type=&quot;text&quot; v-model=&quot;adviceText&quot;&gt;
        &lt;button v-on:click=&quot;$emit('advise', adviceText)&quot;&gt;
          Click me for sending advice
    		&lt;/button&gt;
    	&lt;/div&gt;
    </span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  app<span class="token punctuation">.</span><span class="token function">mount</span><span class="token punctuation">(</span><span class="token string">'#example'</span><span class="token punctuation">)</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p><strong>props传入函数与$emit调用的区别</strong>？</p> <h3 id="eventbus事件总线-emit-on"><a href="#eventbus事件总线-emit-on" class="header-anchor">#</a> eventBus事件总线（$emit/$on）</h3> <p>eventBus适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，一个组件通过$emit('事件名', 传递的参数对象)发出事件，另一个组件通过$on('相同的事件名', function(传递过来的参数对象){...})。</p> <p>Vue3.x已经移除了 $on，$off(移除事件总线监听器) 和 $once 方法。绝大多数情况下不建议使用eventBus在组件间通信，长期看它很难维护，可以通过其他方式来解决，具体看<a href="https://v3.cn.vuejs.org/guide/migration/events-api.html#%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF" target="_blank" rel="noopener noreferrer">事件总线<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <h3 id="依赖注入-provide-inject"><a href="#依赖注入-provide-inject" class="header-anchor">#</a> 依赖注入(provide/inject)</h3> <p>该方法用于<strong>父子or祖孙组件之间通信</strong>，<code>层数很深</code>的情况下可以用这种方式传值。provide/inject 是Vue提供的两个钩子，和data、methods是同级的。</p> <ul><li>provide 钩子用来让父组件发送数据或方法</li> <li>inject 钩子用来给子组件接收数据或方法</li></ul> <p>注：默认情况下依赖注入所提供的属性是<strong>非响应式</strong>的，可以通过computed、ref或reactive来解决。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 祖父组件</span>
<span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">{</span>
    num<span class="token operator">:</span> Vue<span class="token punctuation">.</span><span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span> 
   <span class="token comment">// 让num变成响应式的</span>
   <span class="token comment">// 这里的num是父组件data中的数据，provide必须是一个函数，如果是一个对象就不能传递data中的数据</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 子孙组件</span>
inject<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'num'</span><span class="token punctuation">]</span> <span class="token comment">// 在子组件中通过this.num来调用</span>


<span class="token comment">// 访问父组件中的所有属性</span>
<span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">{</span>
    app<span class="token operator">:</span> <span class="token keyword">this</span> <span class="token comment">// 直接返回父组件实例</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">return</span> <span class="token punctuation">{</span>
    num<span class="token operator">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 子孙组件</span>
inject<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'app'</span><span class="token punctuation">]</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>app<span class="token punctuation">.</span>num<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h3 id="ref-refs"><a href="#ref-refs" class="header-anchor">#</a> ref/$refs</h3> <p>实现<strong>父子组件</strong>之间的通信。</p> <p><code>ref</code>被用来给元素或子组件注册引用信息。引用信息会被注册在父组件的<code>$refs</code>对象上。</p> <ul><li>如果在普通的DOM元素上使用，引用指向的就是这个DOM元素</li> <li>如果用在子组件上，引用就指向组件实例</li></ul> <p>注：因为 ref 本身是作为渲染函数的结果而创建的，在初始渲染时你不能访问它们——它们还不存在！<code>$refs</code> 也是非响应式的，因此不应该试图用它在模板中做数据绑定。</p> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- vm.$refs.p 会是 DOM 节点 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>p<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>hello<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- vm.$refs.child 会是子组件实例 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child-component</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child-component</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 当动态绑定时，我们可以将 ref 定义为回调函数，显式地传递元素或组件实例 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child-component</span> <span class="token attr-name">:ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(el) =&gt; child = el<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child-component</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="parent-children"><a href="#parent-children" class="header-anchor">#</a> $parent/$children</h3> <ul><li>$parent：可以让组件访问上一级父组件的属性和方法（是一个对象）</li> <li>$root：访问根组件的实例</li> <li>$children：可以让组件访问所有直接子组件实例（是一个数组），但是并不能保证顺序且访问的数据也不是响应式的，在Vue3中已被移除，可以使用 $refs 替换</li></ul> <h3 id="attrs-listeners"><a href="#attrs-listeners" class="header-anchor">#</a> $attrs/$listeners</h3> <p>Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。如A是B组件的父组件，B是C组件的父组件，可以使用该方法实现组件A给组件C传递数据。</p> <ul><li>inheritAttrs：默认为true，继承父组件除 props 之外的所有属性；如果设为false，只继承class属性</li> <li>$attrs：
<ul><li>vue2.x：继承所有父组件属性（除prop传递的属性、class和style），一般用在子组件的子元素上</li> <li>vue3.x：继承所有父组件属性，包括class和style，还有监听的事件！如果在子组件的子元素使用v-bind绑定了$attrs，会将class和style一起应用到该元素上，可能会造成视觉效果的破坏</li></ul></li> <li>$listeners：
<ul><li>vue2.x：该属性是一个对象，包含作用在这个组件上的所有监听器，使用<code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li> <li>vue3.x：该对象已被移除，事件监听器成为了<code>$attrs</code>的一部分，可以直接通过$attrs调用</li></ul></li></ul> <div class="language-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- A组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>app<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token comment">&lt;!-- 此处监听了两个事件，可以在B组件或者C组件中直接触发 --&gt;</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child1</span> <span class="token attr-name">:p-child1</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:p-child2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child2<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@test1</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onTest1<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@test2</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>onTest2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child1</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> Child1 <span class="token keyword">from</span> <span class="token string">'./Child1.vue'</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span> Child1 <span class="token punctuation">}</span><span class="token punctuation">,</span>
    methods<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token function">onTest1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test1 running'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">onTest2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test2 running'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- B组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child-1<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>props: {{pChild1}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>$attrs: {{$attrs}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child2</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$attrs<span class="token punctuation">&quot;</span></span> <span class="token attr-name">v-on</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>$listeners<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child2</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">import</span> Child2 <span class="token keyword">from</span> <span class="token string">'./Child2.vue'</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'pChild1'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    components<span class="token operator">:</span> <span class="token punctuation">{</span> Child2 <span class="token punctuation">}</span><span class="token punctuation">,</span>
    inheritAttrs<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'test1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 触发APP.vue中的test1方法</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- C组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child-2<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>props: {{pChild2}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>$attrs: {{$attrs}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'pChild2'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    inheritAttrs<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'test2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 触发APP.vue中的test2方法</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br></div></div><ul><li>C组件中能直接触发test的原因在于B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性(子组件继承父组件的事件)</li> <li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li></ul> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p><strong>父子组件间通信</strong>：</p> <ul><li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li> <li>通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。</li> <li>使用 provide/inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li></ul> <p><strong>兄弟组件间通信</strong>：</p> <ul><li>（不推荐）使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li> <li>通过 $parent/$refs 来获取到兄弟组件，也可以进行通信。</li></ul> <p><strong>任意组件之间</strong>：</p> <ul><li>（不推荐）使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li> <li>使用Vuex</li></ul> <h2 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h2> <h3 id="路由懒加载"><a href="#路由懒加载" class="header-anchor">#</a> 路由懒加载</h3> <p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就会更加高效。</p> <p><code>component</code> (和 <code>components</code>) 配置接收一个返回 Promise 组件的函数，Vue Router <strong>只会在第一次进入页面时才会获取这个函数</strong>，然后使用缓存数据。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 非懒加载</span>
<span class="token keyword">import</span> List <span class="token keyword">from</span> <span class="token string">'@/components/list.vue'</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> List <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 1. 箭头函数 + import动态加载</span>
<span class="token keyword">const</span> <span class="token function-variable function">List</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/components/list.vue'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span> path<span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span> component<span class="token operator">:</span> List <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 2. 箭头函数 + require动态加载</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
   <span class="token punctuation">{</span>
     path<span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span>
     <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'@/components/list'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 3. webpack的require.ensure（按模块划分懒加载）</span>
<span class="token comment">// 后面的'list'为ChunkName，多个路由指定相同的chunkName，会合并打包成一个js文件。</span>
<span class="token keyword">const</span> <span class="token function-variable function">List</span> <span class="token operator">=</span> <span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> require<span class="token punctuation">.</span><span class="token function">ensure</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@/components/list'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'list'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    path<span class="token operator">:</span> <span class="token string">'/list'</span><span class="token punctuation">,</span>
    component<span class="token operator">:</span> List<span class="token punctuation">,</span> 
    name<span class="token operator">:</span> <span class="token string">'list'</span>
  <span class="token punctuation">}</span>
 <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h3 id="路由的hash和history模式"><a href="#路由的hash和history模式" class="header-anchor">#</a> 路由的hash和history模式</h3> <h4 id="hash模式-默认的路由模式"><a href="#hash模式-默认的路由模式" class="header-anchor">#</a> hash模式（默认的路由模式）</h4> <p>hash模式是开发中默认的模式，location.hash值就是url中<code>#</code>后面的一串东西。</p> <p><strong>特点</strong>：</p> <ol><li>hash虽然出现在URL里，但是不会被包含在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。</li> <li>这种模式浏览器支持度很好，低版本的IE浏览器也支持。</li> <li>兼容性好但不美观。</li></ol> <p>hash模式的主要原理就是<code>onhashchange</code>事件：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function-variable function">onhashchange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>oldURL<span class="token punctuation">,</span> event<span class="token punctuation">.</span>newURL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">let</span> hash <span class="token operator">=</span> location<span class="token punctuation">.</span>hash<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>在页面hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应代码。</li> <li>hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。</li></ul> <h4 id="history模式"><a href="#history模式" class="header-anchor">#</a> history模式</h4> <p>history模式的URL中没有#，它使用的是传统的<strong>路由分发模式</strong>，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。</p> <p><strong>特点</strong>：虽然看着更美观了，但是history模式需要后台配置支持，如果后台没有正确配置（没有相应的路由或资源），访问时会返回404。</p> <p><strong>修改历史状态</strong>：利用了HTML5 History Interface 中新增的 <code>pushState()</code>和<code>replaceState()</code>方法。</p> <p>这两个方法应用于浏览器的历史记录栈，提供对历史记录进行修改的功能。但调用他们进行修改时，虽然修改了URL，但浏览器不会立即向后端发送请求，这样就可以实现“更新视图但不重新请求页面”的效果。</p> <p><strong>切换历史状态</strong>：包括forward()、back()、go()三个方法，对应浏览器的前进、后退、跳转操作。</p> <p>进行以下配置就能切换到history模式（后端也要配置）：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  mode<span class="token operator">:</span> <span class="token string">'history'</span><span class="token punctuation">,</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="两种模式对比"><a href="#两种模式对比" class="header-anchor">#</a> 两种模式对比</h4> <p>调用history.pushState()相比于直接修改hash，存在以下优势：</p> <ul><li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li> <li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li> <li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li> <li>pushState() 可额外设置 title 属性供后续使用。</li></ul> <p>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对应的路由处理，将返回404错误。</p> <h3 id="获取页面的hash变化"><a href="#获取页面的hash变化" class="header-anchor">#</a> 获取页面的hash变化</h3> <ol><li><p>监听$route的变化</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 监听,当路由发生变化的时候执行</span>
watch<span class="token operator">:</span> <span class="token punctuation">{</span>
  $route<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">handler</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 深度观察监听</span>
    deep<span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>window.location.hash读取#值</p> <p>window.location.hash的值可读可写，读取来判断状态是否改变；写入可以在不重载网页的前提下，添加一条历史访问记录。</p></li></ol> <h3 id="route和-router的区别"><a href="#route和-router的区别" class="header-anchor">#</a> $route和$router的区别</h3> <ul><li>$route是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li> <li>$router 是“路由实例对象”，包括了路由的跳转方法，钩子函数等。</li></ul> <h3 id="路由传参"><a href="#路由传参" class="header-anchor">#</a> 路由传参</h3> <p>需求：把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User 组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。</p> <h4 id="params"><a href="#params" class="header-anchor">#</a> params</h4> <ol><li><p>配置路由：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">{</span>
	path<span class="token operator">:</span> <span class="token string">'/user/:userId'</span><span class="token punctuation">,</span>
	name<span class="token operator">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span>
	component<span class="token operator">:</span> user
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>传入参数</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 1</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;'/user/'+userId&quot;</span><span class="token operator">&gt;</span>用户<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>
<span class="token comment">// 2</span>
<span class="token comment">// 这里的name为路由配置中的name，params为要传入的参数对象</span>
<span class="token operator">&lt;</span>router<span class="token operator">-</span>link <span class="token operator">:</span>to<span class="token operator">=</span><span class="token string">&quot;{name: 'user', params: {userId: userId}}&quot;</span><span class="token operator">&gt;</span>用户<span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>link<span class="token operator">&gt;</span>
<span class="token comment">// 3</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/user/'</span><span class="token operator">+</span>userId<span class="token punctuation">)</span>
<span class="token comment">// 4</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> params<span class="token operator">:</span> <span class="token punctuation">{</span>userId<span class="token operator">:</span> userId<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ol> <p><strong>注</strong>：</p> <ul><li>解析后的地址为<code>/user/1</code>这样的形式</li> <li>获取参数：<code>this.$route.params.userId</code></li> <li>params对象可以传入多个参数，但是每个参数都要在路由中进行配置。如果未配置，参数会在刷新后丢失</li> <li>params传参，只能用路由的&quot;name&quot;访问，如果用&quot;path&quot;，params不起作用</li></ul> <h4 id="query"><a href="#query" class="header-anchor">#</a> query</h4> <p>query不用配置路由，直接传参就行。可以使用</p> <ol><li><code>&lt;router-link :to=&quot;...&quot;&gt;按钮&lt;/router-link&gt;</code></li> <li><code>this.$router.push(...)</code></li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// ...里面可以填入以下内容</span>
<span class="token comment">// 1</span>
<span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'user'</span><span class="token punctuation">,</span> query<span class="token operator">:</span> <span class="token punctuation">{</span>id<span class="token operator">:</span> id<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token comment">// 2</span>
<span class="token punctuation">{</span>path<span class="token operator">:</span> <span class="token string">'/user'</span><span class="token punctuation">,</span> query<span class="token operator">:</span> <span class="token punctuation">{</span>id<span class="token operator">:</span> id<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token comment">// 3</span>
<span class="token string">'/user?id='</span><span class="token operator">+</span>id
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>注</strong>：</p> <ul><li>解析后的地址为<code>/user?id=1</code>这样的形式</li> <li>获取参数：<code>this.$route.query.userId</code></li> <li>query使用&quot;name&quot;或&quot;path&quot;引入都可以</li></ul> <h4 id="两者对比"><a href="#两者对比" class="header-anchor">#</a> 两者对比</h4> <ol><li>params是路由的一部分，如果配置了一定要传；query是拼接在url后面的参数，没传也没关系。</li> <li>params、query不设置也可以传参，但是params不设置时，刷新页面或返回参数会丢失；query不会。</li></ol> <h3 id="vue-router跳转和location-href"><a href="#vue-router跳转和location-href" class="header-anchor">#</a> Vue-router跳转和location.href</h3> <ul><li><code>location.href=url</code>：简单方便，但是会刷新页面</li> <li><code>history.pushState(url)</code>：不会刷新页面，静态跳转</li> <li><code>router.push(url)</code>：引入router，使用该方法来跳转。使用了 diff 算法，实现了按需加载，减少了dom的消耗。使用router方法和使用 history.pushState() 没什么差别，因为vue-router就是用了 history.pushState()，尤其是history模式下。</li></ul> <h3 id="导航守卫"><a href="#导航守卫" class="header-anchor">#</a> 导航守卫</h3> <ul><li>全局守卫/钩子：beforeEach、beforeResolve、afterEach</li> <li>路由独享守卫：beforeEnter</li> <li>组件内守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li></ul> <p>具体可参考<a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener noreferrer">导航守卫<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>导航行为被触发到导航完成的整个过程</strong>：</p> <ol><li>导航被触发，此时导航未被确认。</li> <li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li> <li>调用全局的 <code>beforeEach</code> 守卫。</li> <li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫(2.2+)。</li> <li>在路由配置里调用 <code>beforeEnter</code>。</li> <li>解析异步路由组件（如果有）。</li> <li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li> <li>调用全局的 <code>beforeResolve</code> 守卫(2.5+)，表示解析阶段完成。</li> <li>导航被确认。</li> <li>调用全局的 <code>afterEach</code> 钩子。</li> <li>非重用组件，开始组件实例（及keep-alive）的生命周期：beforeCreate、created、beforeMount、（deactivated）、mounted、（activated）。</li> <li>触发 DOM 更新。</li> <li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li> <li>导航完成。</li></ol> <h3 id="对前端路由的理解"><a href="#对前端路由的理解" class="header-anchor">#</a> 对前端路由的理解</h3> <p>在前端技术早期，一个url对应一个页面，如果想从页面A切换到页面B，必然伴随着页面刷新。用户只有在刷新页面的情况下，才能重新去请求数据。</p> <p>ajax的出现，让用户可以在不刷新页面的情况下发起请求；也出现了“不刷新页面即可更新页面内容”这种需求。在这种背景下出现了SPA（单页面应用），但是刚出现SPA时，人们并没有考虑到“定位”这个问题：</p> <ul><li>SPA不会“记住”你的操作：在内容切换前后，页面的url都是一样的，SPA不知道当前页面“进展到哪一步”，一刷新页面，一切操作就会被清零。</li> <li>由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息。</li></ul> <p>为了解决这个问题，前端路由出现了。它可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步，即为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。实现这个目的首先要解决两个问题：</p> <ol><li>当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li> <li>单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li></ol> <p>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：</p> <ul><li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li> <li>感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li></ul> <h2 id="vuex"><a href="#vuex" class="header-anchor">#</a> Vuex</h2> <p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式 + 库</strong>。它采用集中式存储管理应用的所有组件的状态，其状态存储是响应式的。每一个Vuex应用的核心就是store（仓库）。</p> <p><img src="https://s2.loli.net/2022/03/27/LswSngMBXQztAqZ.png" alt="vuex"></p> <ol><li>改变store中的状态唯一途径就是显式提交 mutation，该方法只能进行同步操作，且方法名全局唯一。</li> <li>Vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。</li></ol> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token comment">// 基本数据</span>
  state<span class="token operator">:</span> <span class="token punctuation">{</span>
    count<span class="token operator">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token comment">// 从基本数据派生出的数据</span>
  getters<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">countPlus</span><span class="token operator">:</span> <span class="token parameter">state</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token comment">// 提交更改数据的方法，同步</span>
  mutations<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">increment</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> payload</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count <span class="token operator">+=</span> payload
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token comment">// Action可以包含任意异步操作，提交的是mutation，而不是直接变更状态。</span>
  actions<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 写异步代码</span>
      <span class="token operator">...</span>
      context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token operator">:</span> <span class="token string">'.app'</span><span class="token punctuation">,</span>
  store<span class="token punctuation">,</span>
  computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">count</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">increment</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">
        &lt;div&gt;
            {{ count }}
            &lt;button @click='increment'&gt;点我&lt;/button&gt;
        &lt;/div&gt;
    </span><span class="token template-punctuation string">`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br></div></div><h3 id="为什么vuex的mutation中不能做异步操作"><a href="#为什么vuex的mutation中不能做异步操作" class="header-anchor">#</a> 为什么Vuex的mutation中不能做异步操作？</h3> <ol><li>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li> <li>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li></ol> <h3 id="vuex和localstorage的区别"><a href="#vuex和localstorage的区别" class="header-anchor">#</a> vuex和localStorage的区别</h3> <ul><li>vuex存储在内存中；localStorage以文件方式存在本地，只能存储字符串类型的数据。读取内存比读取硬盘速度要快。</li> <li>vuex用于组件之间传值，能做到数据的响应式；localStorage是将数据存储到浏览器中，一般是在跨页面传递数据时使用</li> <li>属性页面时vuex存储的值会丢失，localStorage不会</li></ul> <h2 id="vue3-0"><a href="#vue3-0" class="header-anchor">#</a> Vue3.0</h2> <h2 id="响应式"><a href="#响应式" class="header-anchor">#</a> 响应式</h2> <h3 id="双向数据绑定"><a href="#双向数据绑定" class="header-anchor">#</a> 双向数据绑定</h3> <p>Vue是采用<code>数据劫持</code>结合<code>发布者-订阅者模式</code>的方式来实现双向数据绑定的。</p> <p>当Vue实例创建时，Vue会遍历data中的属性，用Object.defineProperty（vue3.0使用proxy）将它们转化为getter/setter，在数据变动时发布消息给订阅者，触发相应的监听回调。每个组件实例都有相应的 watcher 实例。主要分为以下几个步骤：</p> <ol><li>需要Observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter/getter，给这个对象的某个值赋值，就会触发setter，这样就可以监听到数据变化。</li> <li>Compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，<code>添加监听数据的订阅者</code>，一旦数据有变动，收到通知，更新视图。</li> <li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
<ol><li>在自身实例化时往订阅器管理员(dep)里面添加自己</li> <li>自身必须有一个update()方法，待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退</li></ol></li></ol> <p><img src="https://s2.loli.net/2022/03/27/UodsHcta9XiMW2Q.png" alt="image-20220308201858759"></p> <h3 id="object-defineproperty与proxy"><a href="#object-defineproperty与proxy" class="header-anchor">#</a> Object.defineProperty与Proxy</h3> <p><strong>Object.defineProperty缺点</strong>：</p> <ol><li>无法监听数组的变化，Vue内部通过重写数组的8种方法来检测数组变化。除了这8种，其他数组属性都检测不到，比如<code>通过下标方式修改数组数据</code>或者<code>给对象新增属性</code>，这都不能触发组件的重新渲染。</li> <li>只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历。</li></ol> <p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。</p> <p><strong>Proxy的优点</strong>：</p> <ol><li>Proxy可以直接劫持整个对象，并返回一个新对象，不管是操作便利程度还是底层功能都远胜Object.defineProperty。</li> <li>Proxy可以无压力监听数组的变化。</li> <li>Proxy有13中拦截方式，是Object.defineProperty不具备的。</li> <li>如果对象在vue实例创建后新增属性，一样可以监听到，不需要使用<code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li> <li>0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示。</li></ol> <p>Proxy 唯一的缺点是兼容性的问题，因为它是 ES6 的语法。</p> <p>可参考<a href="https://juejin.cn/post/6844903601416978439" target="_blank" rel="noopener noreferrer">面试官: 实现双向绑定Proxy比defineproperty优劣如何?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="vue模板编译"><a href="#vue模板编译" class="header-anchor">#</a> Vue模板编译</h2> <h2 id="虚拟dom"><a href="#虚拟dom" class="header-anchor">#</a> 虚拟DOM</h2> <p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。其设计最初的目的就是跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，使用vue内部封装的diff算法来比较现在的虚拟DOM会与缓存的虚拟DOM，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p> <h3 id="为什么要用虚拟dom"><a href="#为什么要用虚拟dom" class="header-anchor">#</a> 为什么要用虚拟DOM？</h3> <ol><li>Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。</li> <li>跨平台：Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</li></ol> <h3 id="diff算法原理"><a href="#diff算法原理" class="header-anchor">#</a> Diff算法原理</h3> <p><strong>Vnode最大的用途就是在数据变化前后生成真实DOM对应的虚拟DOM节点，然后就可以对比新旧两份VNode，找出差异所在，然后更新有差异的DOM节点，最终达到以最少操作真实DOM更新视图的目的。</strong></p> <p>在新老虚拟DOM对比时：</p> <ul><li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li> <li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li> <li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li> <li>匹配时，找到相同的子节点，递归比较子节点</li></ul> <p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p> <h3 id="vue中key的作用"><a href="#vue中key的作用" class="header-anchor">#</a> Vue中key的作用</h3> <p>vue 中 key 值的作用可以分为两种情况来考虑：</p> <ul><li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li> <li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li></ul> <p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p> <ul><li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key === b.key对比中可以避免就地复用的情况。所以会更加准确。</li> <li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li></ul> <p>diff算法的过程中，先会进行新旧节点的首尾交叉对比，当无法匹配的时候会用新节点的key与旧节点进行对比，从而找到相应的旧节点。</p> <h4 id="为什么不建议用index作为key"><a href="#为什么不建议用index作为key" class="header-anchor">#</a> 为什么不建议用index作为key？</h4> <p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blog/docs/interview/javascript.html" class="prev">
            JavaScript
          </a></span> <span class="next"><a href="/blog/docs/interview/chrome.html">
            浏览器
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-70334359><li class="level-2" data-v-70334359><a href="/blog/docs/interview/vue.html#vue基础" class="sidebar-link reco-side-vue基础" data-v-70334359>Vue基础</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#computed、watch与methods" class="sidebar-link reco-side-computed、watch与methods" data-v-70334359>computed、watch与methods</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#v-if、v-show与v-html" class="sidebar-link reco-side-v-if、v-show与v-html" data-v-70334359>v-if、v-show与v-html</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#v-if和v-for的优先级问题" class="sidebar-link reco-side-v-if和v-for的优先级问题" data-v-70334359>v-if和v-for的优先级问题</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#v-model语法糖" class="sidebar-link reco-side-v-model语法糖" data-v-70334359>v-model语法糖</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#data为什么是一个函数而不是对象" class="sidebar-link reco-side-data为什么是一个函数而不是对象" data-v-70334359>data为什么是一个函数而不是对象</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#slot插槽" class="sidebar-link reco-side-slot插槽" data-v-70334359>slot插槽</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#对keep-alive组件的理解" class="sidebar-link reco-side-对keep-alive组件的理解" data-v-70334359>对keep-alive组件的理解</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#nexttick的原理及作用" class="sidebar-link reco-side-nexttick的原理及作用" data-v-70334359>$nextTick的原理及作用</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#vm-set" class="sidebar-link reco-side-vm-set" data-v-70334359>vm.$set()</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#vue如何收集依赖" class="sidebar-link reco-side-vue如何收集依赖" data-v-70334359>Vue如何收集依赖</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#单页面应用与多页面应用" class="sidebar-link reco-side-单页面应用与多页面应用" data-v-70334359>单页面应用与多页面应用</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#预渲染" class="sidebar-link reco-side-预渲染" data-v-70334359>预渲染</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#ssr" class="sidebar-link reco-side-ssr" data-v-70334359>SSR</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/interview/vue.html#生命周期" class="sidebar-link reco-side-生命周期" data-v-70334359>生命周期</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#父子组件生命周期钩子执行顺序" class="sidebar-link reco-side-父子组件生命周期钩子执行顺序" data-v-70334359>父子组件生命周期钩子执行顺序</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/interview/vue.html#组件通信" class="sidebar-link reco-side-组件通信" data-v-70334359>组件通信</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#props-emit" class="sidebar-link reco-side-props-emit" data-v-70334359>props/$emit</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#eventbus事件总线-emit-on" class="sidebar-link reco-side-eventbus事件总线-emit-on" data-v-70334359>eventBus事件总线（$emit/$on）</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#依赖注入-provide-inject" class="sidebar-link reco-side-依赖注入-provide-inject" data-v-70334359>依赖注入(provide/inject)</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#ref-refs" class="sidebar-link reco-side-ref-refs" data-v-70334359>ref/$refs</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#parent-children" class="sidebar-link reco-side-parent-children" data-v-70334359>$parent/$children</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#attrs-listeners" class="sidebar-link reco-side-attrs-listeners" data-v-70334359>$attrs/$listeners</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#总结" class="sidebar-link reco-side-总结" data-v-70334359>总结</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/interview/vue.html#路由" class="sidebar-link reco-side-路由" data-v-70334359>路由</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#路由懒加载" class="sidebar-link reco-side-路由懒加载" data-v-70334359>路由懒加载</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#路由的hash和history模式" class="sidebar-link reco-side-路由的hash和history模式" data-v-70334359>路由的hash和history模式</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#获取页面的hash变化" class="sidebar-link reco-side-获取页面的hash变化" data-v-70334359>获取页面的hash变化</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#route和-router的区别" class="sidebar-link reco-side-route和-router的区别" data-v-70334359>$route和$router的区别</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#路由传参" class="sidebar-link reco-side-路由传参" data-v-70334359>路由传参</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#vue-router跳转和location-href" class="sidebar-link reco-side-vue-router跳转和location-href" data-v-70334359>Vue-router跳转和location.href</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#导航守卫" class="sidebar-link reco-side-导航守卫" data-v-70334359>导航守卫</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#对前端路由的理解" class="sidebar-link reco-side-对前端路由的理解" data-v-70334359>对前端路由的理解</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/interview/vue.html#vuex" class="sidebar-link reco-side-vuex" data-v-70334359>Vuex</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#为什么vuex的mutation中不能做异步操作" class="sidebar-link reco-side-为什么vuex的mutation中不能做异步操作" data-v-70334359>为什么Vuex的mutation中不能做异步操作？</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#vuex和localstorage的区别" class="sidebar-link reco-side-vuex和localstorage的区别" data-v-70334359>vuex和localStorage的区别</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/interview/vue.html#vue3-0" class="sidebar-link reco-side-vue3-0" data-v-70334359>Vue3.0</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/interview/vue.html#响应式" class="sidebar-link reco-side-响应式" data-v-70334359>响应式</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#双向数据绑定" class="sidebar-link reco-side-双向数据绑定" data-v-70334359>双向数据绑定</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#object-defineproperty与proxy" class="sidebar-link reco-side-object-defineproperty与proxy" data-v-70334359>Object.defineProperty与Proxy</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/interview/vue.html#vue模板编译" class="sidebar-link reco-side-vue模板编译" data-v-70334359>Vue模板编译</a></li><li class="level-2" data-v-70334359><a href="/blog/docs/interview/vue.html#虚拟dom" class="sidebar-link reco-side-虚拟dom" data-v-70334359>虚拟DOM</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#为什么要用虚拟dom" class="sidebar-link reco-side-为什么要用虚拟dom" data-v-70334359>为什么要用虚拟DOM？</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#diff算法原理" class="sidebar-link reco-side-diff算法原理" data-v-70334359>Diff算法原理</a></li><li class="level-3" data-v-70334359><a href="/blog/docs/interview/vue.html#vue中key的作用" class="sidebar-link reco-side-vue中key的作用" data-v-70334359>Vue中key的作用</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/blog/assets/js/app.14bc1ec9.js" defer></script><script src="/blog/assets/js/3.38776f79.js" defer></script><script src="/blog/assets/js/1.88753400.js" defer></script><script src="/blog/assets/js/88.4dd8de33.js" defer></script>
  </body>
</html>
